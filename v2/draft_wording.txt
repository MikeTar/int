Wide int: 64 standard bits are not enough


Introduction:

Current standard provides signed and unsigned int8_t, int16_t, int32_t, int64_t. It is usually enough for every day tasks, but sometimes appears a need in big numbers : for cryptography, IPv6, very big counters etc. Non-standard type __int128 which is provided by gcc and clang illuminates this need. But there is no cross-platform solution without any framework or library working with big numbers: openssl for example. And all (known for me) libraries have complicated interface for subj.
You can say: "128 bits will be enough" and the next session of C++ standard committee will start with a new draft about int256_t and the next time it will be about int512_t.
It would be great to solve this problem for any purpose in the library. It is very difficult to do in the language.
So, community needs a solution, which will include:
 - any size of int;
 - simple interface;
 - good support in the standard library (std::to_string(), for example);
 - the same behaviour as fundamental integral types.


Solution:

As a solution we propose a template with args <int bits, bool is_signed> and with the same behaviour as fundamental integral types.
Limitations are: arg bits - is power of 2, bits >= 128.
It must be POD. We'll provide constexpr as much as possible.


Possible implementation:

https://github.com/cerevra/int.git/v2
